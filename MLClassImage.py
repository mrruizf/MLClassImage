# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MLClassImage
                                 A QGIS plugin
 Plugin para QGIS 3.X para la clasificación de imágenes satelitales mediante algoritmos de machine learning. (SVM, KNN, RF)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Marlon Ruiz / Universidad Distrital
        email                : mrruizf@correo.udistrital.edu.co
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QAbstractTableModel, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox, QTableView, QHeaderView

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .MLClassImage_dialog import MLClassImageDialog,MLClassImageDialogResult
import os.path
from osgeo import gdal,ogr,gdal_array

import os
import numpy as np
import pandas as pd

class pandasModel(QAbstractTableModel):

    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data

    def rowCount(self, parent=None):
        return self._data.shape[0]

    def columnCount(self, parnet=None):
        return self._data.shape[1]

    def data(self, index, role=Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
        return None

    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

class MLClassImage:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MLClassImage_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&MLClassImage')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MLClassImage', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/MLClassImage/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Clasificación de Imagenes Machine Learning'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&MLClassImage'),
                action)
            self.iface.removeToolBarIcon(action)

#############################################################################################
#############################################################################################
#############################################################################################
#############################################################################################
#############################################################################################
#############################################################################################
    def run(self):
        """Run method that performs all the real work"""
        #self.dlg.cmbMetodo.clear()
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = MLClassImageDialog()
            self.dlg.btnImagenEntrada.clicked.connect(self.select_image_entry)
            self.dlg.btnClases.clicked.connect(self.select_feature_entry)
            self.dlg.cmbClases.currentIndexChanged.connect(self.list_fields_feature)
            self.dlg.btnImagenSalida.clicked.connect(self.select_output_file)
            self.dlg.btnLimpiar.clicked.connect(self.clean_parameters)
            self.dlg.btnSalir.clicked.connect(self.exit_system)
            self.dlg.cmbMetodo.addItems(['','KNN','SVM','RF'])
            self.dlg.txtRecorte.setText(str(40))
            self.dlg.cmbMetodo.currentIndexChanged.connect(self.select_method)
            self.dlg.btnEjecutar.clicked.connect(self.ejecutar) #Probando que funciona la validación
            #self.dlg.btnEjecutar.clicked.connect(self.loadSettings)
        #
        # show the dialog
        self.dlg.show()
        
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
    #Función que selecciona la ruta de la imagen
    def select_image_entry(self):
        self.rutaImagenEntrada = QFileDialog.getOpenFileName(self.dlg,
          "Seleccione la imagen","", "TIFF (*.TIF *.tif *.TIFF *.tiff);;JPEG (*.JPEG *.jpeg *.JPG *.jpg *.JPE *.jpe *JFIF *.jfif);; PNG (*.PNG *.png);; GIF (*.GIF *.gif);; Bitmap Files (*.BMP *.bmp *.DIB *.dib);; ICO (*.ICO *.ico)")
        self.dlg.txtImagenEntrada.setText(self.rutaImagenEntrada[0])
    #Función que selecciona el shape file con las clases
    def select_feature_entry(self):
        self.rutaClases = QFileDialog.getOpenFileName(self.dlg,
          "Seleccione las clases","", "shp(*.shp)")
        self.dlg.txtClases.setText(self.rutaClases[0])
        print("Shapefile Seleccionado \n"+self.dlg.txtClases.text())
        try:
            self.dlg.cmbClases.addItems(self.list_fields_feature(self.dlg.txtClases.text()))
        except:
            pass
    
    def list_fields_feature(self,FileName):
        #self.dlg.cmbClases.clear()
        #FileName = self.dlg.txtClases.text()
        print("Entrando al listado de campos "+str(FileName))
        DriverName = "ESRI Shapefile"
        driver = ogr.GetDriverByName(DriverName)
        if os.path.exists(FileName):
            dataSource = driver.Open(FileName, 0)
            lyr=dataSource.GetLayer()
            layerDefinition = lyr.GetLayerDefn()
            fieldName = []
            for i in range(layerDefinition.GetFieldCount()):
                fieldName.append(layerDefinition.GetFieldDefn(i).GetName())
                print(layerDefinition.GetFieldDefn(i).GetName())
            return fieldName
            
    def select_method(self):
        if self.dlg.cmbMetodo.currentText() == 'KNN':
            self.dlg.txtParametro.setText(str(6))
            self.dlg.lblParametro.setText('K Vecinos')
            #N_N=6
        elif self.dlg.cmbMetodo.currentText() == 'RF':
            self.dlg.txtParametro.setText(str(150))
            self.dlg.lblParametro.setText('Núm. Árboles')
            #num_trees = 150
        elif self.dlg.cmbMetodo.currentText() == 'SVM':
            self.dlg.txtParametro.setText(str(3))
            self.dlg.lblParametro.setText('Grado RBF')
            #degree=3
        else:
            self.dlg.txtParametro.setText('')
            self.dlg.lblParametro.setText('Parámetro')
    def isfloat(self,num):
        try:
            float(num)
            return True
        except ValueError:
            return False
        
    def validate_params_method(self,metodo,parametro,recorte):
        if parametro.isdigit() and self.isfloat(recorte):
            parametro = int(parametro)
            recorte = float(recorte)
            if recorte>=30 and recorte<=50:
                if metodo == 'SVM':
                    if parametro >=3 and parametro<=9:
                        return True
                    else:
                        QMessageBox.critical(None,"Párametros no validos",f"El valor debe estar 3<=p<=9 y debe ser entero")
                        return False
                if metodo == 'KNN':
                    if parametro >=6:
                        return True
                    else:
                        QMessageBox.critical(None,"Párametros no validos",f"El valor no debe ser inferior a 6 y entero")
                        return False
                if metodo == 'RF':
                    if parametro >=50:
                        return True
                    else:
                        QMessageBox.critical(None,"Párametros no validos",f"Por recomendación debe ser entero y mayor a 50")
                        return False
            else:
                QMessageBox.critical(None,"Párametros no validos",f"Por recomendación el recorte debe ser de tipo numerico positivo entre 30<=R<=50")
                return False
        else:
            QMessageBox.critical(None,"Párametros no validos",f"Los parámetros deben ser númericos")
            return False
    
    def select_output_file(self):
        filename, _filter = QFileDialog.getSaveFileName(self.dlg, "Seleccione el archivo de salida","",'*.tif')
        self.dlg.txtImagenSalida.setText(filename)
        
    def clean_parameters(self):
        self.dlg.txtImagenEntrada.clear()
        self.dlg.txtClases.clear()
        self.dlg.cmbClases.clear()
        self.dlg.cmbMetodo.clear()
        self.dlg.cmbMetodo.addItems(['','KNN','SVM','RF'])
        self.dlg.txtImagenSalida.clear()
        
    def exit_system(self):
        self.clean_parameters()
        self.dlg.close()
        
    def validate_params(self,image,fetureclass,fieldname,methodml):
        if image == '' or fetureclass == '' or fieldname == '' or methodml == '':
            QMessageBox.critical(None,"Párametros no validos",f"Por favor valide los párametros ingresados")
            return False
        else:
            return True
            
    def extract_calss(self,inputPath,FileName,clases):
        #FileName = self.dlg.txtClases.text()
        DriverName = "ESRI Shapefile"
        driver = ogr.GetDriverByName(DriverName)
        dataSource = driver.Open(FileName, 0)
        lyr=dataSource.GetLayer()
        nombreFiled = self.dlg.cmbClases.currentText()
        listaClases = []
        for i in range(lyr.GetFeatureCount()):
            feature = lyr.GetFeature(i)
            atributos = feature.items()
            listaClases.append(atributos[nombreFiled])
            print(atributos[nombreFiled])
        listaClases = list(set(listaClases))
        print(listaClases)
        #inputPath = self.dlg.txtImagenEntrada.text()
        Image  = gdal.Open(inputPath)
        nBands = Image.RasterCount
        #Creando el diccionario donde se realizará el corte
        obj = {}
        for j in range(nBands):
            obj[clases] = []
            print("Banda"+str(j))
            obj['Band_'+str(j+1)] = []
            
        for i in range(len(listaClases)):
            SQL = "SELECT * FROM "+str(dataSource.GetDescription()).split("/")[-1].split(".")[0]+" WHERE "+"""{0} = '{1}'""".format(nombreFiled,str(listaClases[i]))
            print(SQL)
            options = gdal.WarpOptions(cutlineDSName  = FileName,cutlineSQL=SQL,cropToCutline=True,dstNodata = 0)
            result = gdal.Warp(srcDSOrSrcDSTab=inputPath,destNameOrDestDS=inputPath.split(".")[0]+"_"+listaClases[i]+".tif",options=options) 
            if result is None:    
                print('Failed')
            else:
                print('Success')
            #print(np.where(result.GetRasterBand(1).ReadAsArray() != 0)[1])
            obj[clases].extend([listaClases[i]]*len((np.where(result.GetRasterBand(1).ReadAsArray() != 0)[1]).tolist()))
            for j in range(nBands):
                print("Cantidad de elementos en el recorte, Banda "+str(j+1)+": "+str(len(np.where(result.GetRasterBand(j+1).ReadAsArray() != 0)[1])))
                obj['Band_'+str(j+1)].extend((np.where(result.GetRasterBand(j+1).ReadAsArray() != 0)[1]).tolist())
                #obj["Clases"].append(listaClases[i])
            result = None
        return obj
        
    def image_to_matrix(self,imagen):
        Image = gdal.Open(imagen)
        img = np.zeros((Image.RasterYSize, Image.RasterXSize, Image.RasterCount),
        gdal_array.GDALTypeCodeToNumericTypeCode(Image.GetRasterBand(1).DataType))
        print(img.shape)
        for b in range(img.shape[2]):
            img[:, :, b] = Image.GetRasterBand(b + 1).ReadAsArray()
        img_as_array = img.reshape(-1, img.shape[2])
        return img_as_array
        
    def saveRaster(self,dataset,datasetPath,imagen,listaClases):
        """.
        Image = gdal.Open(imagen)
        rows  = ds.RasterYSize
        cols  = ds.RasterXSize
        projection = ds.GetProjection()
        rasterSet = gdal.GetDriverByName('GTiff').Create(datasetPath, cols, rows,1,gdal.GDT_Float32)
        rasterSet.SetProjection(projection)
        rasterSet.SetGeoTransform(geotransform)
        rasterSet.GetRasterBand(1).WriteArray(dataset)
        rasterSet.GetRasterBand(1).SetNoDataValue(-999)
        rasterSet = None
        """
        Image = gdal.Open(imagen)
        lista_final = []
        for i, element in enumerate(dataset):
            for j, element_clase in enumerate(listaClases):
                if element_clase==element:
                    lista_final.append(j+1)
                    #print(listaClases[j])
        array_pred = np.array(lista_final)
        array_pred = np.reshape(array_pred, (Image.RasterYSize, Image.RasterXSize), order='C')
        geotrans = Image.GetGeoTransform()
        proj = Image.GetProjection()
        cols = array_pred.shape[1]
        rows = array_pred.shape[0]
        driver = gdal.GetDriverByName('GTiff')
        outRaster = driver.Create(datasetPath, cols, rows, 1, gdal.GDT_Byte)
        outRaster.SetGeoTransform(geotrans)
        outRaster.SetProjection(proj)
        outband = outRaster.GetRasterBand(1)
        outband.WriteArray(array_pred)
        outband.FlushCache()
        outRaster = None
        self.iface.addRasterLayer(imagen,'Imagen Original')
        self.iface.addRasterLayer(datasetPath,'Clasificacion')
    
    def ejecutar(self):
         if self.validate_params(self.dlg.txtImagenEntrada.text(),self.dlg.txtClases.text(),self.dlg.cmbClases.currentText(),self.dlg.cmbMetodo.currentText()) and self.validate_params_method(self.dlg.cmbMetodo.currentText(),self.dlg.txtParametro.text(),self.dlg.txtRecorte.text()):
            #QMessageBox.information(None,"Ejecutanto","Ejecuntando el algoritmo, por favor espere")
            obj = self.extract_calss(self.dlg.txtImagenEntrada.text(),self.dlg.txtClases.text(),self.dlg.cmbClases.currentText())
            clase = list(set(obj[self.dlg.cmbClases.currentText()]))
            print(type(clase))
            print("\n\n\n")
            print(clase)
            self.clasificacion = pd.DataFrame(clase,columns =['Clases'])
            from sklearn.model_selection import train_test_split
            from sklearn.metrics import accuracy_score
            from sklearn.metrics import classification_report
            from sklearn.metrics import confusion_matrix
            df = pd.DataFrame.from_dict(obj)
            X = df.drop(columns = self.dlg.cmbClases.currentText())
            y = df[[self.dlg.cmbClases.currentText()]]
            recorte_train = float(int(self.dlg.txtRecorte.text())/100)
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=recorte_train, random_state=0)
            if self.dlg.cmbMetodo.currentText() == 'SVM':
                from sklearn.svm import SVC
                grado = int(self.dlg.txtParametro.text())
                modelo = SVC(C=200, kernel='rbf', degree=grado, cache_size=2048)
                modelo.fit(X_train, y_train)
                predicciones = modelo.predict(X_test)
                accuracy = accuracy_score(y_true= y_test,y_pred= predicciones,normalize = True)
                print(f"La presicición del test es: {100*accuracy}%")
                report = classification_report(y_test, predicciones, output_dict=True)
                del report['accuracy']
                self.report = pd.DataFrame(report).transpose().reset_index()
                #print(report)
                self.matconfusion = pd.DataFrame(confusion_matrix(y_test, predicciones,labels=clase),columns = clase,index=clase).reset_index()
                #print(matconfusion)
                img_as_array = self.image_to_matrix(self.dlg.txtImagenEntrada.text())
                print("\n\nSe esta realizando la predicción")
                class_prediction = modelo.predict(img_as_array)
                self.saveRaster(class_prediction,self.dlg.txtImagenSalida.text(),self.dlg.txtImagenEntrada.text(),clase)
            elif self.dlg.cmbMetodo.currentText() == 'RF':
                from sklearn.ensemble import RandomForestClassifier
                num_trees = int(self.dlg.txtParametro.text())
                rf = RandomForestClassifier(n_estimators=num_trees, max_depth=None, n_jobs=-1,oob_score=True)
                rf.fit(X_train, y_train)
                predicciones_rf = rf.predict(X_test)
                accuracy = accuracy_score(y_true= y_test,y_pred= predicciones_rf,normalize = True)
                print(f"La presicición del test es: {100*accuracy}%")
                report = classification_report(y_test, predicciones_rf, output_dict=True)
                del report['accuracy']
                self.report = pd.DataFrame(report).transpose().reset_index()
                #print(report)
                self.matconfusion = pd.DataFrame(confusion_matrix(y_test, predicciones_rf,labels=clase),columns = clase,index=clase).reset_index()
                #print(matconfusion)
                img_as_array = self.image_to_matrix(self.dlg.txtImagenEntrada.text())
                print("\n\nSe esta realizando la predicción")
                class_prediction = rf.predict(img_as_array)
                self.saveRaster(class_prediction,self.dlg.txtImagenSalida.text(),self.dlg.txtImagenEntrada.text(),clase)
            elif self.dlg.cmbMetodo.currentText() == 'KNN':
                from sklearn.neighbors import KNeighborsClassifier
                N_N=int(self.dlg.txtParametro.text())
                knn = KNeighborsClassifier(n_neighbors=N_N)
                knn.fit(X_train, y_train)
                knn_pred = knn.predict(X_test)
                accuracy = accuracy_score(y_true= y_test,y_pred= knn_pred,normalize = True)
                print(f"La presicición del test es: {100*accuracy}%")
                report = classification_report(y_test, knn_pred, output_dict=True)
                del report['accuracy']
                self.report = pd.DataFrame(report).transpose().reset_index()
                #print(report)
                self.matconfusion = pd.DataFrame(confusion_matrix(y_test, knn_pred,labels=clase),columns = clase,index=clase).reset_index()
                #print(matconfusion)
                img_as_array = self.image_to_matrix(self.dlg.txtImagenEntrada.text())
                print("\n\nSe esta realizando la predicción")
                class_prediction = knn.predict(img_as_array)
                self.saveRaster(class_prediction,self.dlg.txtImagenSalida.text(),self.dlg.txtImagenEntrada.text(),clase)
            self.loadSettings(accuracy)
                
    def loadSettings(self,accuracy):
        """!@brief load settings dock"""
        self.dlg1 = MLClassImageDialogResult()
        self.dlg1.show()
        self.dlg1.btnSalir1.clicked.connect(self.exit_dialog)
        model = pandasModel(self.report)
        print(model)
        self.dlg1.tblReporte.setModel(model)
        model = pandasModel(self.matconfusion)
        print(model)
        self.dlg1.tblMatriz.setModel(model)
        self.dlg1.lblAcuracy.setText(f"La presicición del test es: {100*accuracy}%")
        ########################################################################
        self.dlg1.btnGuardar.clicked.connect(self.select_output_excel)
  
    def select_output_excel(self):
        try:
            filename, _filter = QFileDialog.getSaveFileName(self.dlg1, "Guardar el reporte de salida","",'*.xlsx')
        except:
            pass
        self.clasificacion.index = np.arange(1,len(self.clasificacion)+1)
        self.clasificacion.reset_index()
        with pd.ExcelWriter(filename) as writer:
            self.clasificacion.to_excel(writer, sheet_name='Clases')
            self.report.to_excel(writer, sheet_name='Reporte')
            self.matconfusion.to_excel(writer, sheet_name='Matriz de Confusion')
        writer.save()
        
    def exit_dialog(self):
        #self.clean_parameters()
        self.dlg1.close()

    